
//Steering servo controls generated by receiver
//maximum pulse length is 1840 us
//neutral position  pulse length is 1520 us
//minimum pulse length is 1160 us

//ESC pwm control signals generated by receiver.
//Full reverse 1000 us
//Neutral 1500 us
//Full throttle 2000 us

#include <Arduino.h>
#define USE_USBCON
#include <ros.h>
#include <sacar/Encoder.h>
#include <sacar/ESC.h>

#include <Servo.h>
#include "controlParams.h"

Servo steeringservo;  // create servo object to control a servo
Servo driveservo;


// Variables for time step
volatile unsigned long dt;
volatile unsigned long t0;

// Variables for control signals
int max_pulse = 1860;
int min_pulse  = 1220;
float degree_division = (max_pulse - min_pulse) / 180.0;
volatile int steering_degree = 90;
volatile int throttle_percent = 0;
//frequency generated is 50Hz
int max_throttle_pulse = 1700;
int min_throttle_pulse = 1220;
float throttle_percent_division = (max_throttle_pulse - min_throttle_pulse) / 100.0;

// Variables for encoder distance calculation
float distance_constant = 30; // distance in centimeters that wheel travels before encoder interrupt
volatile int FL_encoder_count  = 0;
volatile int FR_encoder_count = 0;
volatile int BL_encoder_count  = 0;
volatile int BR_encoder_count = 0;
int speed_update_period = 100; //in milliseconds


int steeringToPulseWidth(int degree) {
  if (degree < 0 || degree > 180) {
    return 0; //if bad input, ignore and don't send input to servo.
  }

  return degree * degree_division + min_pulse;
}

int throttleToPulseWidth(int throttle_percent) {
  if (throttle_percent < -100) {
    throttle_percent = -100;
  }
  if (throttle_percent > 100) {
    throttle_percent = 100;
  }
  return throttle_percent * throttle_percent_division + (min_throttle_pulse + max_throttle_pulse) / 2;
}

void set_up_reverse() {
  driveservo.writeMicroseconds(throttleToPulseWidth(-30));
  delay(500);
  driveservo.writeMicroseconds(throttleToPulseWidth(0));
  delay(100);
  return;
}

void controllCallback(const sacar::ESC& ESCcont) {
  //update control servos when receiving a message to do so
  steeringservo.writeMicroseconds(ESCcont.steering_pulse);
  driveservo.writeMicroseconds(ESCcont.throttle_pulse);
}

ros::NodeHandle nh;

sacar::Encoder enc_msg;

ros::Publisher encoder_speed("encoder_speed",  &enc_msg);
ros::Subscriber<sacar::ESC> targetcontrols("throttleandsteering", controllCallback);

void FLencoderISR() {
  FL_encoder_count++;
}

void FRencoderISR() {
  FR_encoder_count++;
}

void BLencoderISR() {
  BL_encoder_count++;
}

void BRencoderISR() {
  BR_encoder_count++;
}

void setup() {
  nh.initNode();
  nh.advertise(encoder_speed);
  nh.subscribe(targetcontrols);
  //attachInterrupt(digitalPinToInterrupt(0), FLencoderISR, RISING);  //attaches pin 0 interrupt to encoder interrupt handler on rising edge
  //attachInterrupt(digitalPinToInterrupt(1), FRencoderISR, RISING);  //attaches pin 1 interrupt to encoder interrupt handler on rising edge
  attachInterrupt(digitalPinToInterrupt(2), BLencoderISR, RISING);  //attaches pin 2 interrupt to encoder interrupt handler on rising edge
  attachInterrupt(digitalPinToInterrupt(3), BRencoderISR, RISING);  //attaches pin 3 interrupt to encoder interrupt handler on rising edge
  steeringservo.attach(9);  // attaches the servo on pin 9 to the steering servo
  driveservo.attach(10); // attaches the servo on pin 10 to the drive servo
  steeringservo.writeMicroseconds(1600);
  driveservo.writeMicroseconds(1600);
  t0 = millis();
}
void loop() {
  //publish speed data every speed_update_period ms
  dt = millis() - t0;

  if (dt > speed_update_period) {
    //uint16_t leftspeed = left_encoder_count * distance_constant * (1000 / speed_update_period);
    //uint16_t rightspeed = right_encoder_count * distance_constant * (1000 / speed_update_period);
    //in centimeters per second

    enc_msg.FL = FL_encoder_count;
    enc_msg.FR = FR_encoder_count;
    enc_msg.BL = BL_encoder_count;
    enc_msg.BR = BR_encoder_count;
    encoder_speed.publish(&enc_msg);
    FL_encoder_count = 0;
    FR_encoder_count = 0;
    BL_encoder_count = 0;
    BR_encoder_count = 0;
    t0 = millis();
  }

  nh.spinOnce();
}
